## オブジェクト指向を構成する３つ
- `カプセル化`：データとメソッドを１つのオブジェクトにまとめること
- `継承`：あるオブジェクトが他のオブジェクトに特性を引き継ぐこと、カプセル化が与えてくれなかった機能を補填する意味合い
- `ポリモーフィズム`：中に入るものによって同じ関数でも違う処理を行える（例：動物の鳴き声[ワン, ニャー, グワッ]）


- `クロージャー`：とりあえずネストされた関数を指す


## 設計原則
1. `単一責任の原則（SRP：Single Responsibility Principle）`
-> 個々のモジュールを変更する理由がたった１つになるように
-> 「ユーザーやステークホルダー」= 「変更する理由」
-> モジュールはたった１つのユーザーやステークホルダーに対して責務を負うべき
-> ダメな例：Emproyeeクラス（CalculatePay, ReportHours, Save）
CalculatePay → CFO
ReportHours → COO
Save → CTO
-> `アクター`の異なるコードは分離すべき



2. `オープン・クローズドの原則（OCP：Open Closed Principle）`
-> 既存のコードの変更よりも新しいコードの追加によって、システムの振る舞いを変更できるように赤帰依するべき

3. `リスコフの置換原則（LSP：LiskovSubstitutionPrinciple）`
-> 交換可能なパーツを使って構築するなら、個々のパーツが交換可能となる契約にするべき

4. `インターフェイス分離の原則（ISP：InterfaceSegregationPrinciple）`
-> 使っていないものへの依存度を回避するべき

5. `依存関係逆転の原則（DIP：DependencyInversionPrinciple） `
-> 方針（上位レベル）のコードは、詳細（下位レベル）のコードに依存するべきでなく、詳細側が方針側に依存すべき


## アーキテクチャがサポートするべきもの
1. システムのユースケース(システムの振る舞いを把握するための技法・使う人目線の設計内容)
2. システムの運用
3. システムの開発


## ビジネスルール
- `最重要ビジネスルール`：銀行がローンにN%の利子を貸し付けている
- `最重要ビジネスデータ`：貸付金残高・金利・支払いスケジュール
- `エンティティ`：ビジネスルールとビジネスデータは密接な関係 = オブジェクトの有力候補（エンティティとする）
-> エンティティは、DB, UI, サードパーティのフレームワークについて何も気にする必要はない（ビジネスそのものであるから=ビジネスロジック）
- `ユースケース`：エンティティの最重要ビジネスルールをいつ・どこで呼び出すかを示している
-> 入力データを期待し、出力データを生成する

***優れたアーキテクチャは、ユースケースを中心にしているため、フレームワーク・ツール・環境に依存することなくユースケースをサポートする仕組みを問題なく説明できる***
-> フレームワークの決定をプロジェクトの後半まで決定する必要がない
-> フレームワークにアーキテクチャを乗っ取られてはいけない


## クリーンアーキテクチャ
- `テスト可能`：外部機能がなくてもテストできることが望ましい
- `UI非依存`：UIは、システムの他の部分を変更することなく簡単に変更できる
- `データベース非依存`：他のDBに簡単に置き換えが可能（ビジネスルールはDBに束縛されない）
`外部エージェント非依存`：ビジネスルールは外部のインターフェースについて何も知らない
==============================================================================
- `ドメインロジック`を独立させる
- `フレームワーク`を独立させる
- `UI`を独立させる
- `DBなどの全て`を独立させる
- `ドメインロジック`をテストしやすくする
==============================================================================
- `エンティティ(/domain)`：***企業のビジネスルールをカプセル化したもの***
-> メソッドを持ったオブジェクトでも関数でもデータ構造でも構わない
-> 外部で何かの変化が起きてもエンティティが変化することは低い
- `ユースケース(/usecase)`：***アプリケーション固有のビジネスルールをカプセル化したもの***
-> エンティティに入出力するデータの流れを調節する
-> エンティティに最重要ビジネスルールを使用するように指示を出す
-> このレイヤーの変更がエンティティに影響を与えることはない
-> このレイヤーがフレームワークなど外部の影響を受けることもない
- `インターフェースアダプタ(interfaces)`：
-> プレゼンター、ビュー、コントローラなどのMVCは全てここに含まれている
- `フレームワークとドライバ(infrastructure)`：
-> 例えば、データベースやフレームワークに当たる（あまりコードを書かない部分）


### 簡単なまとめ
エンティティ（企業のビジネスルール） -> /domain
ユースケース（アプリケーション固有のビジネスルール） -> /services/teacher/usecase
インターフェースアダプタ
-> /services/teacher/handler（ルーティング関係）
-> /services/teacher/repojitory（Gatewaysに相当）
フレームワークとドライバ -> /infra（）


## サンプルAPI
├── adapter`(インターフェースアダプタ)`
│   ├── controllers
│   ├── gateway
│   └── interfaces
├── domain`(エンティティ：企業のビジネスルール)`
├── external`(フレームワークとドライバ)`
│   └── mysql
├── main.go
└── usecase`(ユースケース：システム上のビジネスルール)`
    └── interfaces


## まとめ
- 依存性は内側(上位レベルの方針)だけに向かってないといけない
external -> interface -> usecase -> entity

- 内側の変化に応じて外側を呼び出したい場合はどうすべきか？
-> Presentation？？

1. 依存性はより上位レベルの方針`のみ`に向けよ
2. 制御の流れと依存の方向は分離してコントロールせよ

### プロダクト別の総売上をCSV出力するコンソールアプリ
